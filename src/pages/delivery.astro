---
import Layout from "../layouts/Layout.astro";
---

<script src="https://unpkg.com/imask@7.5.0/dist/imask.min.js"></script>

<Layout title="–î–æ—Å—Ç–∞–≤–∫–∞ - –ó–∞–∫–∞–∑—ã">
    <div class="min-h-screen bg-white">
        <header class="bg-green-600 text-white px-4 py-4">
            <div class="max-w-md mx-auto flex items-center relative">
                <a
                    href="/"
                    class="flex items-center justify-center w-10 h-10 hover:bg-white/10 rounded-full transition-all duration-200 active:scale-95 z-10"
                >
                    <svg
                        class="w-6 h-6 text-white"
                        fill="none"
                        stroke="currentColor"
                        viewBox="0 0 24 24"
                        stroke-width="2.5"
                    >
                        <path
                            stroke-linecap="round"
                            stroke-linejoin="round"
                            d="M15 19l-7-7 7-7"></path>
                    </svg>
                </a>
                <h1
                    class="text-lg font-semibold absolute left-1/2 transform -translate-x-1/2"
                >
                    üöö –î–æ—Å—Ç–∞–≤–∫–∞
                </h1>
            </div>
        </header>

        <main class="max-w-md mx-auto px-4 py-6">
            <div id="loadingState" class="text-center py-8">
                <div
                    class="animate-spin h-12 w-12 border-b-2 border-green-600 rounded-full mx-auto"
                >
                </div>
            </div>

            <div id="ordersView" class="space-y-4 hidden">
                <div class="flex space-x-2">
                    <button
                        id="filterAll"
                        class="px-3 py-2 rounded-lg bg-green-600 text-white"
                        >–í—Å–µ</button
                    >
                    <button
                        id="filterPending"
                        class="px-3 py-2 rounded-lg bg-gray-200">–û–∂–∏–¥–∞—é—Ç</button
                    >
                    <button
                        id="filterDelivered"
                        class="px-3 py-2 rounded-lg bg-gray-200"
                        >–î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ</button
                    >
                </div>
                <div id="ordersList"></div>

                <!-- Empty State -->
                <div
                    id="emptyState"
                    class="text-center py-12 text-gray-500 hidden"
                >
                    <div class="text-4xl mb-4">üì¶</div>
                    <p class="text-lg font-medium mb-2">–ù–µ—Ç –∑–∞–∫–∞–∑–æ–≤</p>
                    <p class="text-sm">
                        –°–æ–∑–¥–∞–π—Ç–µ –∑–∞–∫–∞–∑ –≤ —Ä–∞–∑–¥–µ–ª–∞—Ö –ë–∞—Ä, –ö—É—Ö–Ω—è –∏–ª–∏ –ì–æ—Ä–Ω–∏—á–Ω–∞—è
                    </p>
                </div>
            </div>
        </main>
    </div>

    <script is:inline>
        let currentFilter = "all";

        async function loadOrders() {
            try {
                console.log("üîÑ Loading orders from all sources...");

                // Try to load from server storage for cross-device visibility
                let serverOrders = [];
                try {
                    const response = await fetch("/api/get-all-orders", {
                        cache: "no-store",
                    });
                    if (response.ok) {
                        const result = await response.json();
                        serverOrders = Array.isArray(result.data)
                            ? result.data
                            : [];
                        console.log(
                            `üåê Server orders loaded: ${serverOrders.length}`,
                        );
                    }
                } catch (e) {
                    console.warn(
                        "‚ö†Ô∏è Failed to fetch server orders, falling back to localStorage",
                    );
                }

                // Also load local orders (for unsynced/offline items)
                const barOrders = JSON.parse(
                    localStorage.getItem("barOrderHistory") || "[]",
                );
                const kitchenOrders = JSON.parse(
                    localStorage.getItem("kitchenOrderHistory") || "[]",
                );
                const customOrders = JSON.parse(
                    localStorage.getItem("customOrderHistory") || "[]",
                );
                console.log(
                    `üì± Local orders - Bar: ${barOrders.length}, Kitchen: ${kitchenOrders.length}, Custom: ${customOrders.length}`,
                );
                const localOrders = [
                    ...barOrders,
                    ...kitchenOrders,
                    ...customOrders,
                ];

                // Merge by unique key (timestamp + department) with preference:
                // - Prefer delivered over non-delivered
                // - If both delivered, prefer one with later deliveredAt
                // - Otherwise, prefer server version
                function chooseBetter(existing, candidate) {
                    if (!existing) return candidate;
                    const isExistingDelivered = existing.status === "delivered";
                    const isCandidateDelivered =
                        candidate.status === "delivered";
                    if (isExistingDelivered && !isCandidateDelivered)
                        return existing;
                    if (!isExistingDelivered && isCandidateDelivered)
                        return candidate;
                    if (isExistingDelivered && isCandidateDelivered) {
                        const a = existing.deliveredAt
                            ? new Date(existing.deliveredAt).getTime()
                            : 0;
                        const b = candidate.deliveredAt
                            ? new Date(candidate.deliveredAt).getTime()
                            : 0;
                        if (a !== b) return b > a ? candidate : existing;
                        // If same deliveredAt or missing, prefer one with actualTotalQuantity
                        const hasExistingActuals =
                            typeof existing.actualTotalQuantity === "number";
                        const hasCandidateActuals =
                            typeof candidate.actualTotalQuantity === "number";
                        if (hasExistingActuals !== hasCandidateActuals) {
                            return hasCandidateActuals ? candidate : existing;
                        }
                    }
                    // Fallback preference: server over local (mark with a flag below)
                    if (
                        candidate.__source === "server" &&
                        existing.__source !== "server"
                    )
                        return candidate;
                    return existing;
                }

                const mergedMap = new Map();
                for (const o of serverOrders) {
                    const key = `${o.timestamp}|${o.department}`;
                    const candidate = { ...o, __source: "server" };
                    mergedMap.set(
                        key,
                        chooseBetter(mergedMap.get(key), candidate),
                    );
                }
                for (const o of localOrders) {
                    const key = `${o.timestamp}|${o.department}`;
                    const candidate = { ...o, __source: "local" };
                    mergedMap.set(
                        key,
                        chooseBetter(mergedMap.get(key), candidate),
                    );
                }

                const orders = Array.from(mergedMap.values()).sort(
                    (a, b) => new Date(b.timestamp) - new Date(a.timestamp),
                );

                document.getElementById("loadingState").style.display = "none";
                document
                    .getElementById("ordersView")
                    .classList.remove("hidden");
                renderOrders(orders);
            } catch (error) {
                console.error("Failed to load orders:", error);
                // Absolute fallback to localStorage-only
                const fallbackBar = JSON.parse(
                    localStorage.getItem("barOrderHistory") || "[]",
                );
                const fallbackKitchen = JSON.parse(
                    localStorage.getItem("kitchenOrderHistory") || "[]",
                );
                const fallbackCustom = JSON.parse(
                    localStorage.getItem("customOrderHistory") || "[]",
                );
                const fallbackOrders = [
                    ...fallbackBar,
                    ...fallbackKitchen,
                    ...fallbackCustom,
                ].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

                document.getElementById("loadingState").style.display = "none";
                document
                    .getElementById("ordersView")
                    .classList.remove("hidden");
                renderOrders(fallbackOrders);
            }
        }

        function renderOrders(orders) {
            console.log(
                `üîç Rendering orders: ${orders.length} total orders found`,
            );
            console.log("Orders data:", orders);

            // Group orders by timestamp to create unified orders
            const groupedOrders = new Map();
            orders.forEach((order) => {
                if (!order.items || !Array.isArray(order.items)) return;

                const key = order.timestamp;
                if (!groupedOrders.has(key)) {
                    groupedOrders.set(key, {
                        timestamp: order.timestamp,
                        departments: [],
                        allItems: [],
                        status: "pending",
                        deliveredAt: null,
                        totalItems: 0,
                        totalQuantity: 0,
                    });
                }

                const group = groupedOrders.get(key);
                group.departments.push({
                    name: order.departmentName || order.department,
                    department: order.department,
                    items: order.items,
                });
                group.allItems.push(
                    ...order.items.map((item) => ({
                        ...item,
                        department: order.department,
                        departmentName:
                            order.departmentName || order.department,
                    })),
                );

                // Update status - if any department is delivered, mark as delivered
                if (order.status === "delivered") {
                    group.status = "delivered";
                    if (order.deliveredAt) {
                        group.deliveredAt = order.deliveredAt;
                    }
                }

                group.totalItems += order.items.length;
                group.totalQuantity +=
                    order.actualTotalQuantity || order.totalQuantity || 0;
            });

            const unifiedOrders = Array.from(groupedOrders.values()).sort(
                (a, b) => new Date(b.timestamp) - new Date(a.timestamp),
            );

            const filtered =
                currentFilter === "all"
                    ? unifiedOrders
                    : currentFilter === "pending"
                      ? unifiedOrders.filter((o) => o.status !== "delivered")
                      : unifiedOrders.filter((o) => o.status === "delivered");

            console.log(
                `üìã Filtered unified orders: ${filtered.length} orders after filter "${currentFilter}"`,
            );

            const emptyState = document.getElementById("emptyState");
            const ordersList = document.getElementById("ordersList");

            if (filtered.length === 0) {
                ordersList.innerHTML = "";
                emptyState.classList.remove("hidden");
                console.log("üí° Showing empty state - no orders found");
                return;
            } else {
                emptyState.classList.add("hidden");
            }

            ordersList.innerHTML = filtered
                .map((unifiedOrder) => {
                    // Get temporary quantities and prices for all items
                    const tempQuantities = JSON.parse(
                        localStorage.getItem(
                            `temp_${unifiedOrder.timestamp}`,
                        ) || "{}",
                    );
                    const tempPrices = JSON.parse(
                        localStorage.getItem(
                            `temp_prices_${unifiedOrder.timestamp}`,
                        ) || "{}",
                    );

                    return `
                        <div class="bg-white border rounded-lg p-4 mb-4 ${unifiedOrder.status === "delivered" ? "bg-green-50" : ""}">
                            <div class="flex justify-between items-start mb-3">
                                <div>
                                    <p class="text-sm text-gray-500">${new Date(unifiedOrder.timestamp).toLocaleString()}</p>
                                </div>
                                <div class="text-right">
                                    <div class="text-sm font-medium">${unifiedOrder.totalItems} —Ç–æ–≤–∞—Ä–æ–≤</div>
                                    <div class="text-xs text-gray-500">${unifiedOrder.totalQuantity} —à—Ç.</div>
                                </div>
                            </div>

                            <div class="space-y-4 my-3">
                                ${unifiedOrder.departments
                                    .map(
                                        (dept) => `
                                    <div class="space-y-2">
                                        <h4 class="font-semibold text-gray-800 border-b border-gray-200 pb-1">${dept.name}</h4>
                                        ${dept.items
                                            .map((item, i) => {
                                                const globalIndex =
                                                    unifiedOrder.allItems.findIndex(
                                                        (globalItem) =>
                                                            globalItem.name ===
                                                                item.name &&
                                                            globalItem.department ===
                                                                dept.department,
                                                    );
                                                return `
                                            <div class="ml-2">
                                                <div class="flex justify-between items-start mb-2">
                                                    <span class="font-medium text-gray-900">${item.name}</span>
                                                </div>
                                                ${
                                                    unifiedOrder.status !==
                                                    "delivered"
                                                        ? `
                                                    <div class="flex items-center space-x-2">
                                                        <input
                                                            type="text"
                                                            inputmode="numeric"
                                                            pattern="[0-9]*"
                                                            class="quantity-input w-20 px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-green-500 text-center"
                                                            data-order="${unifiedOrder.timestamp}"
                                                            data-index="${globalIndex}"
                                                            data-type="quantity"
                                                            data-unit="${item.unit}"
                                                            placeholder="0 ${item.unit}"
                                                            data-imask-suffix=" ${item.unit}"
                                                            data-initial-value="${tempQuantities[globalIndex] !== undefined ? tempQuantities[globalIndex] : item.quantity}"
                                                        >
                                                        <span class="text-sm text-gray-500 font-medium min-w-max">${item.unit}</span>
                                                        <label class="text-sm text-gray-600 min-w-max ml-4">–∑–∞</label>
                                                        <input
                                                            type="text"
                                                            inputmode="numeric"
                                                            pattern="[0-9]*"
                                                            class="price-input w-24 px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-green-500 text-center"
                                                            data-order="${unifiedOrder.timestamp}"
                                                            data-index="${globalIndex}"
                                                            data-type="price"
                                                            placeholder="0 ‚Ç∏"
                                                            data-imask-suffix=" ‚Ç∏"
                                                            data-initial-value="${tempPrices[globalIndex] !== undefined ? tempPrices[globalIndex] : item.price || 0}"
                                                        >
                                                        <span class="text-sm text-gray-500 font-medium min-w-max"></span>
                                                    </div>
                                                    ${
                                                        (tempQuantities[
                                                            globalIndex
                                                        ] !== undefined &&
                                                            tempQuantities[
                                                                globalIndex
                                                            ] !==
                                                                item.quantity) ||
                                                        (tempPrices[
                                                            globalIndex
                                                        ] !== undefined &&
                                                            tempPrices[
                                                                globalIndex
                                                            ] !==
                                                                (item.price ||
                                                                    0))
                                                            ? `
                                                        <div class="mt-2 p-2 bg-orange-50 border border-orange-200 rounded text-xs text-orange-700 font-medium">
                                                            üí° –ò–∑–º–µ–Ω–µ–Ω–æ: ${tempQuantities[globalIndex] !== undefined ? tempQuantities[globalIndex] : item.quantity} ${item.unit}${tempPrices[globalIndex] !== undefined ? `, ${tempPrices[globalIndex]} ‚Ç∏` : `, ${item.price || 0} ‚Ç∏`}
                                                        </div>
                                                        `
                                                            : ""
                                                    }
                                                    `
                                                        : `
                                                    <div class="mt-2 p-2 bg-green-50 border border-green-200 rounded text-sm text-green-700 font-medium">
                                                        ‚úÖ –ö—É–ø–ª–µ–Ω–æ: ${item.actualQuantity || item.quantity} ${item.unit} –∑–∞ ${item.actualPrice || item.price || 0} ‚Ç∏
                                                    </div>
                                                    `
                                                }
                                            </div>
                                            `;
                                            })
                                            .join("")}
                                    </div>
                                `,
                                    )
                                    .join("")}
                            </div>

                            ${
                                unifiedOrder.status !== "delivered"
                                    ? `
                                <div class="mt-4 flex flex-col gap-2">
                                    <button
                                        onclick="addMissingProducts('${unifiedOrder.timestamp}')"
                                        class="w-full bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg font-medium transition-colors duration-200 flex items-center justify-center space-x-2"
                                    >
                                        <span>‚ûï</span>
                                        <span>–î–æ–±–∞–≤–∏—Ç—å –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ —Ç–æ–≤–∞—Ä—ã</span>
                                    </button>
                                    <button
                                        onclick="markUnifiedDelivered('${unifiedOrder.timestamp}')"
                                        class="w-full bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-lg font-medium transition-colors duration-200"
                                    >
                                        –û—Ç–º–µ—Ç–∏—Ç—å –≤–µ—Å—å –∑–∞–∫–∞–∑ –∫–∞–∫ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ
                                    </button>
                                    <button
                                        onclick="deleteUnifiedOrder('${unifiedOrder.timestamp}')"
                                        class="w-full bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg font-medium transition-colors duration-200"
                                    >
                                        üóë –£–¥–∞–ª–∏—Ç—å –≤–µ—Å—å –∑–∞–∫–∞–∑
                                    </button>
                                </div>
                                `
                                    : `
                                <div class="space-y-2">
                                    <div class="text-center text-green-600 font-medium">‚úÖ –î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ</div>
                                    <button
                                        onclick="downloadUnifiedOrderXLS('${unifiedOrder.timestamp}')"
                                        class="w-full bg-blue-600 hover:bg-blue-700 text-white py-2 rounded-lg transition-colors duration-200 flex items-center justify-center space-x-2"
                                    >
                                        <span>üìÑ</span>
                                        <span>–°–∫–∞—á–∞—Ç—å –ø–æ–ª–Ω—ã–π Excel –∑–∞–∫–∞–∑</span>
                                    </button>
                                    <button
                                        onclick="deleteUnifiedOrder('${unifiedOrder.timestamp}')"
                                        class="w-full bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg font-medium transition-colors duration-200 mt-2"
                                    >
                                        üóë –£–¥–∞–ª–∏—Ç—å –≤–µ—Å—å –∑–∞–∫–∞–∑
                                    </button>
                                </div>
                                `
                            }
                        </div>
                    `;
                })
                .join("");

            // Setup input masks after rendering
            setupInputMasks();
        }

        function saveQuantity(e) {
            const order = e.target.dataset.order;
            const index = e.target.dataset.index;
            const quantity = parseFloat(e.target.value) || 0;

            const tempKey = `temp_${order}`;
            const temp = JSON.parse(localStorage.getItem(tempKey) || "{}");
            temp[index] = quantity;
            localStorage.setItem(tempKey, JSON.stringify(temp));

            // Add this line to see changes immediately
            loadOrders();
        }

        function savePrice(e) {
            const order = e.target.dataset.order;
            const index = e.target.dataset.index;
            const price = parseFloat(e.target.value) || 0;

            const tempKey = `temp_prices_${order}`;
            const temp = JSON.parse(localStorage.getItem(tempKey) || "{}");
            temp[index] = price;
            localStorage.setItem(tempKey, JSON.stringify(temp));

            // Add this line to see changes immediately
            loadOrders();
        }

        // Setup input masks for quantity and price inputs
        function setupInputMasks() {
            // Setup quantity input masks
            document.querySelectorAll(".quantity-input").forEach((input) => {
                const unit = input.dataset.unit;
                const order = input.dataset.order;
                const index = input.dataset.index;

                // Create IMask instance for quantity input
                const mask = IMask(input, {
                    mask: Number,
                    scale: 2, // digits after point
                    signed: false, // disallow negative
                    thousandsSeparator: "", // don't use thousands separator
                    padFractionalZeros: false, // don't pad with zeros
                    normalizeZeros: true, // normalize zeros
                    radix: ".", // fractional delimiter
                    min: 0,
                    max: 999,
                    lazy: false, // always show mask

                    // Custom format with unit suffix
                    format: function (appended, masked) {
                        return masked.value + (masked.value ? " " + unit : "");
                    },

                    parse: function (str) {
                        return str.replace(" " + unit, "");
                    },
                });

                // Handle value changes
                mask.on("accept", function () {
                    const value = parseFloat(mask.unmaskedValue) || 0;
                    saveQuantity({
                        target: {
                            dataset: {
                                order: order,
                                index: index,
                            },
                            value: value,
                        },
                    });
                });

                // Store mask instance for later use
                input._mask = mask;

                // Set initial value
                const initialValue = input.dataset.initialValue;
                if (initialValue) {
                    updateInputValue(input, parseFloat(initialValue) || 0);
                }
            });

            // Setup price input masks
            document.querySelectorAll(".price-input").forEach((input) => {
                const order = input.dataset.order;
                const index = input.dataset.index;

                // Create IMask instance for price input
                const mask = IMask(input, {
                    mask: Number,
                    scale: 2, // digits after point for prices
                    signed: false, // disallow negative
                    thousandsSeparator: "", // don't use thousands separator
                    padFractionalZeros: false, // don't pad with zeros
                    normalizeZeros: true, // normalize zeros
                    radix: ".", // fractional delimiter
                    min: 0,
                    max: 99999,
                    lazy: false, // always show mask

                    // Custom format with currency suffix
                    format: function (appended, masked) {
                        return masked.value + (masked.value ? " ‚Ç∏" : "");
                    },

                    parse: function (str) {
                        return str.replace(" ‚Ç∏", "");
                    },
                });

                // Handle value changes
                mask.on("accept", function () {
                    const value = parseFloat(mask.unmaskedValue) || 0;
                    savePrice({
                        target: {
                            dataset: {
                                order: order,
                                index: index,
                            },
                            value: value,
                        },
                    });
                });

                // Store mask instance for later use
                input._mask = mask;

                // Set initial value
                const initialValue = input.dataset.initialValue;
                if (initialValue) {
                    updateInputValue(input, parseFloat(initialValue) || 0);
                }
            });
        }

        // Update input values programmatically
        function updateInputValue(input, newValue) {
            if (input._mask) {
                // For IMask inputs, set the unmasked value
                try {
                    input._mask.unmaskedValue = newValue.toString();
                } catch (error) {
                    // Fallback: set the raw value
                    const suffix = input.dataset.imaskSuffix || "";
                    input.value = newValue + (newValue ? suffix : "");
                }
            } else {
                // For regular inputs, set the raw value
                const suffix = input.dataset.imaskSuffix || "";
                input.value = newValue + (newValue ? suffix : "");
            }
        }

        // New function to mark unified order as delivered
        async function markUnifiedDelivered(timestamp) {
            console.log(
                `üöö [Delivery] Marking unified order as delivered: ${timestamp}`,
            );

            // First, search all localStorage keys for orders
            const allStorageKeys = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.includes("OrderHistory")) {
                    allStorageKeys.push(key);
                }
            }
            console.log(
                `üìÇ [Delivery] Found localStorage keys:`,
                allStorageKeys,
            );

            let updatedOrders = [];
            let foundInStorage = false;

            // Search in all order history keys
            for (const storageKey of allStorageKeys) {
                console.log(`üîç [Delivery] Checking ${storageKey}...`);
                let orders = JSON.parse(
                    localStorage.getItem(storageKey) || "[]",
                );
                let orderIndex = orders.findIndex(
                    (o) => o.timestamp === timestamp,
                );
                console.log(
                    `  üì¶ [Delivery] localStorage has ${orders.length} orders, orderIndex: ${orderIndex}`,
                );

                if (orderIndex !== -1) {
                    foundInStorage = true;
                    console.log(
                        `  ‚úÖ [Delivery] Found order in ${storageKey}!`,
                    );

                    // Get saved quantities and prices
                    const tempKey = `temp_${timestamp}`;
                    const tempPricesKey = `temp_prices_${timestamp}`;
                    const tempQuantities = JSON.parse(
                        localStorage.getItem(tempKey) || "{}",
                    );
                    const tempPrices = JSON.parse(
                        localStorage.getItem(tempPricesKey) || "{}",
                    );

                    // Update order with actual quantities and prices
                    orders[orderIndex].items.forEach((item, i) => {
                        const savedQuantity = tempQuantities[i];
                        const savedPrice = tempPrices[i];
                        if (savedQuantity !== undefined) {
                            item.actualQuantity = savedQuantity;
                        }
                        if (savedPrice !== undefined) {
                            item.actualPrice = savedPrice;
                        }
                    });

                    // Update order status
                    orders[orderIndex].status = "delivered";
                    orders[orderIndex].deliveredAt = new Date().toISOString();

                    // Calculate new total quantity
                    orders[orderIndex].actualTotalQuantity = orders[
                        orderIndex
                    ].items.reduce(
                        (sum, item) =>
                            sum + (item.actualQuantity || item.quantity),
                        0,
                    );

                    // Save changes to localStorage
                    localStorage.setItem(storageKey, JSON.stringify(orders));
                    updatedOrders.push(orders[orderIndex]);

                    // Also save to server storage - use update endpoint instead of create
                    if (orders[orderIndex].db_id) {
                        console.log(
                            `  üåê [Delivery] Updating server order with db_id: ${orders[orderIndex].db_id}`,
                        );
                        try {
                            const updateResponse = await fetch(
                                "/api/update-order-status",
                                {
                                    method: "POST",
                                    headers: {
                                        "Content-Type": "application/json",
                                    },
                                    body: JSON.stringify({
                                        orderId: orders[orderIndex].db_id,
                                        status: "delivered",
                                        deliveredItems: orders[
                                            orderIndex
                                        ].items.map((item) => ({
                                            id: item.id,
                                            deliveredQuantity:
                                                item.actualQuantity ||
                                                item.quantity,
                                        })),
                                    }),
                                },
                            );
                            const updateResult = await updateResponse.json();
                            console.log(
                                `  ‚úÖ [Delivery] Server update result:`,
                                updateResult,
                            );
                        } catch (error) {
                            console.warn(
                                "‚ö†Ô∏è Error updating server order:",
                                error,
                            );
                        }
                    } else {
                        console.log(
                            `  ‚ö†Ô∏è [Delivery] No db_id found for order, skipping server update`,
                        );
                    }
                }
            }

            // If not found in any localStorage, try fetching from server
            if (!foundInStorage) {
                console.log(
                    `üåê [Delivery] Order not found in localStorage, fetching ALL orders from server...`,
                );
                try {
                    const resp = await fetch("/api/get-all-orders", {
                        cache: "no-store",
                    });
                    if (resp.ok) {
                        const result = await resp.json();
                        console.log(
                            `  ‚úÖ [Delivery] Server returned ${result.data?.length || 0} total orders`,
                        );
                        const serverOrder = (result.data || []).find((o) => {
                            // Match by timestamp in order_data or db_created_at
                            return (
                                o.timestamp === timestamp ||
                                (o.db_created_at &&
                                    new Date(o.db_created_at).toISOString() ===
                                        timestamp)
                            );
                        });
                        console.log(
                            `  üîç [Delivery] Looking for timestamp ${timestamp}, found:`,
                            serverOrder ? "YES" : "NO",
                        );

                        if (serverOrder && serverOrder.db_id) {
                            console.log(
                                `  üì• [Delivery] Found server order, updating status...`,
                            );

                            // Get saved quantities and prices
                            const tempKey = `temp_${timestamp}`;
                            const tempPricesKey = `temp_prices_${timestamp}`;
                            const tempQuantities = JSON.parse(
                                localStorage.getItem(tempKey) || "{}",
                            );
                            const tempPrices = JSON.parse(
                                localStorage.getItem(tempPricesKey) || "{}",
                            );

                            // Update server order directly
                            try {
                                const updateResponse = await fetch(
                                    "/api/update-order-status",
                                    {
                                        method: "POST",
                                        headers: {
                                            "Content-Type": "application/json",
                                        },
                                        body: JSON.stringify({
                                            orderId: serverOrder.db_id,
                                            status: "delivered",
                                            deliveredItems:
                                                serverOrder.items.map(
                                                    (item, i) => ({
                                                        id: item.id,
                                                        deliveredQuantity:
                                                            tempQuantities[
                                                                i
                                                            ] !== undefined
                                                                ? tempQuantities[
                                                                      i
                                                                  ]
                                                                : item.quantity,
                                                    }),
                                                ),
                                        }),
                                    },
                                );
                                const updateResult =
                                    await updateResponse.json();
                                console.log(
                                    `  ‚úÖ [Delivery] Server update result:`,
                                    updateResult,
                                );
                                if (updateResult.success) {
                                    updatedOrders.push(serverOrder);
                                }
                            } catch (error) {
                                console.warn(
                                    "‚ö†Ô∏è Error updating server order:",
                                    error,
                                );
                            }
                        }
                    }
                } catch (e) {
                    console.warn("‚ö†Ô∏è Could not fetch orders from server:", e);
                }
            }

            console.log(
                `  ‚û°Ô∏è [Delivery] Final result: ${foundInStorage ? "found" : "not found"}`,
            );

            // Clear temporary data
            localStorage.removeItem(`temp_${timestamp}`);
            localStorage.removeItem(`temp_prices_${timestamp}`);

            if (updatedOrders.length > 0) {
                alert(
                    `–í–µ—Å—å –∑–∞–∫–∞–∑ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω! –û–±–Ω–æ–≤–ª–µ–Ω–æ ${updatedOrders.length} –æ—Ç–¥–µ–ª–æ–≤.\n–¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ —Å–∫–∞—á–∞—Ç—å –ø–æ–ª–Ω—ã–π Excel —Ñ–∞–π–ª.`,
                );
                loadOrders();
            } else {
                alert(
                    "–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –∑–∞–∫–∞–∑—ã –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è. –û–±–Ω–æ–≤–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
                );
            }
        }

        // New function to delete unified order
        async function deleteUnifiedOrder(timestamp) {
            if (
                !confirm(
                    "–£–¥–∞–ª–∏—Ç—å –≤–µ—Å—å –∑–∞–∫–∞–∑ –∏–∑ –≤—Å–µ—Ö –æ—Ç–¥–µ–ª–æ–≤? –≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–ª—å–∑—è –æ—Ç–º–µ–Ω–∏—Ç—å.",
                )
            ) {
                return;
            }

            const departments = ["bar", "kitchen", "custom", "storage"];
            let deletedCount = 0;

            for (const department of departments) {
                try {
                    const storageKey = `${department}OrderHistory`;
                    let orders = JSON.parse(
                        localStorage.getItem(storageKey) || "[]",
                    );
                    const originalLength = orders.length;
                    orders = orders.filter((o) => o.timestamp !== timestamp);

                    if (orders.length < originalLength) {
                        localStorage.setItem(
                            storageKey,
                            JSON.stringify(orders),
                        );
                        deletedCount++;
                    }

                    // Try to remove from server storage as well
                    try {
                        await fetch("/api/delete-order", {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                timestamp: timestamp,
                                department: department,
                            }),
                        });
                    } catch (error) {
                        console.warn("‚ö†Ô∏è Failed to delete from server:", error);
                    }
                } catch (error) {
                    console.error(
                        `Failed to delete order from ${department}:`,
                        error,
                    );
                }
            }

            // Also remove temporary data
            localStorage.removeItem(`temp_${timestamp}`);
            localStorage.removeItem(`temp_prices_${timestamp}`);

            loadOrders();
            alert(`–ó–∞–∫–∞–∑ —É–¥–∞–ª–µ–Ω –∏–∑ ${deletedCount} –æ—Ç–¥–µ–ª–æ–≤!`);
        }

        // New function to download unified Excel
        async function downloadUnifiedOrderXLS(timestamp) {
            try {
                console.log(
                    `üìÑ Downloading unified XLS for order: ${timestamp}`,
                );

                const response = await fetch(
                    "/api/download-unified-order-xls",
                    {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ orderTimestamp: timestamp }),
                    },
                );

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(
                        errorData.error || "Failed to download file",
                    );
                }

                // Get the filename from the response headers
                const contentDisposition = response.headers.get(
                    "Content-Disposition",
                );
                let filename = `unified-order-${new Date().toISOString().split("T")[0]}.xlsx`;

                if (contentDisposition) {
                    const filenameMatch =
                        contentDisposition.match(/filename="(.+)"/);
                    if (filenameMatch) {
                        filename = filenameMatch[1];
                    }
                }

                // Create blob and download
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.style.display = "none";
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);

                console.log("‚úÖ Unified Excel file downloaded successfully");
            } catch (error) {
                console.error("‚ùå Error downloading unified Excel:", error);
                alert("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏ —Ñ–∞–π–ª–∞: " + error.message);
            }
        }

        async function markDelivered(timestamp, department) {
            const storageKey = `${department}OrderHistory`;
            let orders = JSON.parse(localStorage.getItem(storageKey) || "[]");
            let orderIndex = orders.findIndex((o) => o.timestamp === timestamp);

            // Fallback: if order not found locally (e.g., created on another device), fetch from server
            if (orderIndex === -1) {
                try {
                    const resp = await fetch(
                        `/api/get-all-orders?department=${encodeURIComponent(department)}`,
                        { cache: "no-store" },
                    );
                    if (resp.ok) {
                        const result = await resp.json();
                        const serverOrder = (result.data || []).find(
                            (o) => o.timestamp === timestamp,
                        );
                        if (serverOrder) {
                            orders.unshift(serverOrder);
                            orderIndex = 0;
                            // Persist this order locally so subsequent ops work
                            localStorage.setItem(
                                storageKey,
                                JSON.stringify(orders),
                            );
                        }
                    }
                } catch (e) {
                    console.warn(
                        "‚ö†Ô∏è Could not fetch order from server for delivery update:",
                        e,
                    );
                }
            }

            if (orderIndex !== -1) {
                // Get saved quantities and prices
                const tempKey = `temp_${timestamp}`;
                const tempPricesKey = `temp_prices_${timestamp}`;
                const tempQuantities = JSON.parse(
                    localStorage.getItem(tempKey) || "{}",
                );
                const tempPrices = JSON.parse(
                    localStorage.getItem(tempPricesKey) || "{}",
                );

                // Update order with actual quantities and prices
                orders[orderIndex].items.forEach((item, i) => {
                    const savedQuantity = tempQuantities[i];
                    const savedPrice = tempPrices[i];
                    if (savedQuantity !== undefined) {
                        item.actualQuantity = savedQuantity;
                    }
                    if (savedPrice !== undefined) {
                        item.actualPrice = savedPrice;
                    }
                });

                // Update order status
                orders[orderIndex].status = "delivered";
                orders[orderIndex].deliveredAt = new Date().toISOString();

                // Calculate new total quantity
                orders[orderIndex].actualTotalQuantity = orders[
                    orderIndex
                ].items.reduce(
                    (sum, item) => sum + (item.actualQuantity || item.quantity),
                    0,
                );

                // Save changes to localStorage
                localStorage.setItem(storageKey, JSON.stringify(orders));
                localStorage.removeItem(tempKey);
                localStorage.removeItem(tempPricesKey);

                // Also save to server storage - use update endpoint instead of create
                let posterSupplyResult = null;
                try {
                    const response = await fetch("/api/update-order-status", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify({
                            orderId: orders[orderIndex].db_id,
                            status: "delivered",
                            deliveredItems: orders[orderIndex].items.map(
                                (item) => ({
                                    id: item.id,
                                    deliveredQuantity:
                                        item.actualQuantity || item.quantity,
                                }),
                            ),
                        }),
                    });

                    if (response.ok) {
                        const result = await response.json();
                        posterSupplyResult = result.poster_supply;
                        console.log(
                            "‚úÖ Order updated on server for download",
                            result,
                        );
                    } else {
                        console.warn("‚ö†Ô∏è Failed to update server order");
                    }
                } catch (error) {
                    console.warn("‚ö†Ô∏è Error updating server order:", error);
                }

                // Show confirmation
                const differences = orders[orderIndex].items.filter(
                    (item) =>
                        (item.actualQuantity &&
                            item.actualQuantity !== item.quantity) ||
                        (item.actualPrice !== undefined &&
                            item.actualPrice !== (item.price || 0)),
                );
                if (differences.length > 0) {
                    const diffText = differences
                        .map((item) => {
                            let changes = [];
                            if (
                                item.actualQuantity &&
                                item.actualQuantity !== item.quantity
                            ) {
                                changes.push(
                                    `–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: ${item.quantity} -> ${item.actualQuantity}`,
                                );
                            }
                            if (
                                item.actualPrice !== undefined &&
                                item.actualPrice !== (item.price || 0)
                            ) {
                                changes.push(
                                    `—Ü–µ–Ω–∞: ${item.price || 0} -> ${item.actualPrice} ‚Ç∏`,
                                );
                            }
                            return `${item.name}: ${changes.join(", ")}`;
                        })
                        .join("\\n");

                    let alertMessage = `–ó–∞–∫–∞–∑ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω!\\n–ò–∑–º–µ–Ω–µ–Ω–∏—è:\\n${diffText}`;

                    // Add Poster supply status
                    if (posterSupplyResult) {
                        if (posterSupplyResult.success) {
                            alertMessage += `\\n\\n‚úÖ –ü–æ—Å—Ç–∞–≤–∫–∞ —Å–æ–∑–¥–∞–Ω–∞ –≤ Poster!`;
                            if (posterSupplyResult.poster_supply_id) {
                                alertMessage += `\\nID –ø–æ—Å—Ç–∞–≤–∫–∏: ${posterSupplyResult.poster_supply_id}`;
                            }
                        } else {
                            alertMessage += `\\n\\n‚ö†Ô∏è –ü–æ—Å—Ç–∞–≤–∫–∞ –≤ Poster –Ω–µ —Å–æ–∑–¥–∞–Ω–∞: ${posterSupplyResult.message || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞"}`;
                        }
                    }

                    alertMessage +=
                        "\\n\\n–¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ —Å–∫–∞—á–∞—Ç—å Excel —Ñ–∞–π–ª.";
                    alert(alertMessage);
                } else {
                    let alertMessage = "–ó–∞–∫–∞–∑ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω!";

                    // Add Poster supply status
                    if (posterSupplyResult) {
                        if (posterSupplyResult.success) {
                            alertMessage += `\\n\\n‚úÖ –ü–æ—Å—Ç–∞–≤–∫–∞ —Å–æ–∑–¥–∞–Ω–∞ –≤ Poster!`;
                            if (posterSupplyResult.poster_supply_id) {
                                alertMessage += `\\nID –ø–æ—Å—Ç–∞–≤–∫–∏: ${posterSupplyResult.poster_supply_id}`;
                            }
                        } else {
                            alertMessage += `\\n\\n‚ö†Ô∏è –ü–æ—Å—Ç–∞–≤–∫–∞ –≤ Poster –Ω–µ —Å–æ–∑–¥–∞–Ω–∞: ${posterSupplyResult.message || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞"}`;
                        }
                    }

                    alertMessage +=
                        "\\n\\n–¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ —Å–∫–∞—á–∞—Ç—å Excel —Ñ–∞–π–ª.";
                    alert(alertMessage);
                }

                loadOrders();
            } else {
                alert(
                    "–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –∑–∞–∫–∞–∑ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è. –û–±–Ω–æ–≤–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
                );
            }
        }

        // Delete order function
        async function deleteOrder(timestamp, department) {
            if (!confirm("–£–¥–∞–ª–∏—Ç—å —ç—Ç–æ—Ç –∑–∞–∫–∞–∑? –≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–ª—å–∑—è –æ—Ç–º–µ–Ω–∏—Ç—å.")) {
                return;
            }

            try {
                // Remove from localStorage
                const storageKey = `${department}OrderHistory`;
                let orders = JSON.parse(
                    localStorage.getItem(storageKey) || "[]",
                );
                orders = orders.filter((o) => o.timestamp !== timestamp);
                localStorage.setItem(storageKey, JSON.stringify(orders));

                // Also remove temporary data
                localStorage.removeItem(`temp_${timestamp}`);
                localStorage.removeItem(`temp_prices_${timestamp}`);

                // Try to remove from server storage as well
                try {
                    await fetch("/api/delete-order", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify({
                            timestamp: timestamp,
                            department: department,
                        }),
                    });
                } catch (error) {
                    console.warn("‚ö†Ô∏è Failed to delete from server:", error);
                }

                // Reload orders
                loadOrders();
                alert("–ó–∞–∫–∞–∑ —É–¥–∞–ª–µ–Ω!");
            } catch (error) {
                console.error("Failed to delete order:", error);
                alert("–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∑–∞–∫–∞–∑–∞!");
            }
        }

        // Event Listeners
        document.getElementById("filterAll").onclick = () => {
            currentFilter = "all";
            loadOrders();
        };
        document.getElementById("filterPending").onclick = () => {
            currentFilter = "pending";
            loadOrders();
        };
        document.getElementById("filterDelivered").onclick = () => {
            currentFilter = "delivered";
            loadOrders();
        };

        // Download XLS function
        async function downloadOrderXLS(timestamp, department) {
            try {
                console.log(
                    `üìÑ Downloading XLS for order: ${timestamp} (${department})`,
                );

                const response = await fetch("/api/download-order-xls", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({
                        orderTimestamp: timestamp,
                        department: department,
                    }),
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(
                        errorData.error || "Failed to download file",
                    );
                }

                // Get the filename from the response headers
                const contentDisposition = response.headers.get(
                    "Content-Disposition",
                );
                let filename = `supply-${department}-${new Date().toISOString().split("T")[0]}.xlsx`;

                if (contentDisposition) {
                    const filenameMatch =
                        contentDisposition.match(/filename="(.+)"/);
                    if (filenameMatch) {
                        filename = filenameMatch[1];
                    }
                }

                // Create blob and download
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);

                console.log(`‚úÖ Downloaded: ${filename}`);

                // Show success message
                alert(`–§–∞–π–ª "${filename}" —É—Å–ø–µ—à–Ω–æ —Å–∫–∞—á–∞–Ω!`);
            } catch (error) {
                console.error("‚ùå Download failed:", error);
                alert(`–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏: ${error.message}`);
            }
        }

        // Add missing products function
        async function addMissingProducts(orderTimestamp) {
            try {
                console.log(
                    `‚ûï Adding missing products to order: ${orderTimestamp}`,
                );

                // Store the order timestamp in localStorage for the modification page
                localStorage.setItem("modifyOrderTimestamp", orderTimestamp);

                // Navigate to order modification page
                window.location.href = `/modify-order?timestamp=${encodeURIComponent(orderTimestamp)}`;
            } catch (error) {
                console.error(
                    "‚ùå Failed to initiate order modification:",
                    error,
                );
                alert(`–û—à–∏–±–∫–∞: ${error.message}`);
            }
        }

        // Initialize
        window.saveQuantity = saveQuantity;
        window.addMissingProducts = addMissingProducts;
        window.savePrice = savePrice;
        window.markDelivered = markDelivered;
        window.downloadOrderXLS = downloadOrderXLS;
        window.deleteOrder = deleteOrder;
        loadOrders();
    </script>
</Layout>
